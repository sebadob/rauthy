import type { I18nAdmin } from './interface.ts';

export let I18nAdminUk: I18nAdmin = {
    api_key: {
        delete1: 'Дійсно видалити цей API-ключ?',
        expires: 'Термін дії',
        generate1: 'Тут ви можете згенерувати новий секрет для цього API ключа.',
        generate2: `Ви побачите цей секрет лише один раз після генерації.
            Коли буде згенеровано новий, старий секрет буде безповоротно перезаписано.
            Цю операцію неможливо скасувати!`,
        generate3: `API ключ повинен передаватися в HTTP заголовку <code>Authorization</code>
            у наступному форматі:`,
        generate4:
            'Ви можете використати наступний <code>curl</code> запит для тестування вашого нового ключа:',
        generate5: 'Якщо у вас не встановлено <code>jq</code> і команда вище не спрацювала:',
        keyName: 'Назва ключа',
        limitedValidity: 'Обмежений термін дії',
    },
    attrs: {
        delete1: 'Дійсно видалити цей атрибут?',
        defaultValue: 'Значення за замовчуванням',
        desc: 'Опис',
        makeEditable: 'Дозволити редагування',
        makeEditableP1:
            'Ви можете змінити цей атрибут, дозволивши користувачам редагувати його самостійно.',
        makeEditableP2: `<b>УВАГА:</b> Це неможливо буде змінити назад! Всі дані, введені користувачем напряму,
            завжди є неперевіреними і НІКОЛИ не повинні використовуватися для будь-якої форми автентифікації чи авторизації!`,
        makeEditableP3: `Атрибут не можна змінити з редагованого на нередагований, оскільки він дозволяв неперевірені
            введення в минулому, незалежно від того, як довго це тривало.`,
        name: 'Назва атрибуту',
        userEditable: 'Редагується користувачем',
    },
    backup: {
        createBackup: 'Створити резервну копію',
        disabledDesc: 'Ця функція доступна, лише якщо Hiqlite налаштовано як базу даних.',
        lastModified: 'Востаннє змінено',
        local: 'Локально',
        name: 'Назва',
        size: 'Розмір',
    },
    clients: {
        backchannelLogout: 'Якщо цей клієнт підтримує {{ OIDC_BCL }}, ви можете вказати URI тут.',
        branding: {
            descHsl: `Наступні значення мають бути вказані як HSL-значення. Ви вказуєте лише базові кольори.
            Альфа-канали та інші значення динамічно змінюються темою.`,
            descFullCss: `Наступні значення мають бути повністю валідними CSS-значеннями <code>color</code>.
                Ви також можете використовувати складні обчислення або визначені вище CSS-змінні.`,
            descVariables: `Кожна наступна мітка є водночас назвою CSS-змінної. Це означає,
                що ви можете посилатися на них у довільних полях, наприклад: <code>hsla(var(--action) / .7)</code>.`,
        },
        confidential: 'Конфіденційний',
        confidentialNoSecret: 'Цей клієнт не є конфіденційним, тому не має секрету.',
        config: 'Конфігурація клієнта',
        delete1: 'Дійсно видалити цього клієнта?',
        descAuthCode: `Термін дії кодів авторизації можна налаштувати для підвищення безпеки. Коди авторизації
            можна використати лише один раз, і за замовчуванням вони дійсні 60 секунд. Чим коротший термін дії,
            тим краще, за умови, що клієнт може виконати процедуру входу достатньо швидко.`,
        descClientUri: `Інформація про URI цього клієнта та контакти для відображення
            на сторінці входу.`,
        descName: `Назву клієнта можна змінити без будь-якого впливу на його конфігурацію.
            Вона існує лише для відображення на сторінці входу.`,
        descGroupPrefix: `Вхід до цього клієнта може бути обмежений необов'язковим префіксом групи.
            Лише користувачі, які належать до відповідної групи, зможуть увійти.`,
        descOrigin: `Зовнішні, додатково дозволені джерела (origins) — зазвичай потрібні, лише якщо цей клієнт
            має робити запити до Rauthy безпосередньо з браузера, типово для SPA.`,
        descPKCE: `Якщо клієнт це підтримує, вам слід завжди активувати S256 PKCE для додаткової
            безпеки. Якщо використовується неконфіденційний клієнт (наприклад, SPA), ви повинні
            активувати принаймні один із методів PKCE для достатнього рівня безпеки.`,
        descPKCEEnforce: `Якщо будь-який PKCE активовано, Rauthy вимагатиме його використання під час входів і
            відхилятиме запити, що не містять дійсного виклику.`,
        descUri: `Ви можете вказати скільки завгодно URI для перенаправлення. В кінці кожного можна використати
            <code>*</code> як шаблон.`,
        errConfidentialPKCE: `Клієнт повинен бути або конфіденційним, або мати активованим принаймні один
            метод PKCE.`,
        forceMfa: 'Вимагати MFA',
        groupLoginPrefix: 'Префікс групи для входу',
        name: 'Назва клієнта',
        scim: {
            baseUri: `Базовий URI для SCIM — це той, з якого можна коректно вивести під-маршрути,
                наприклад <code>{base_uri}/Users/{id}</base_uri></code>.`,
            desc: 'Якщо цей клієнт підтримує {{ SCIM_LINK }}, ви можете активувати його тут.',
            enable: 'Активувати SCIMv2',
            groupSync: 'Синхронізувати групи',
            groupSyncPrefix: 'Префікс для фільтрації груп',
            groupSyncPrefixDesc: `Ви можете відфільтрувати групи для синхронізації за допомогою необов'язкового префіксу.
                Наприклад, якщо існують групи <code>app:admins</code> та <code>app:users</code>, префікс
                <code>app:</code> синхронізуватиме лише ці групи, а також лише тих користувачів, які прив'язані хоча б
                до однієї з них.`,
            reqDesc: 'Для сумісності необхідно дотримуватися кількох вимог:',
            reqLi1: 'Клієнт повинен коректно обробляти <code>externalId</code>.',
            reqLi2: `Має підтримуватися щонайменше ендпоінт <code>/Users</code> із запитами
                <code>filter=externalId eq "*"</code> та <code>filter=userName eq "*"</code>.`,
            reqLi3: `Якщо групи теж синхронізуються, <code>/Groups</code> має підтримувати
                <code>filter=displayName eq "*"</code>.`,
        },
        scopes: {
            allowed: 'Дозволені скоупи',
            default: 'Скоупи за замовчуванням',
            desc: `Дозволені скоупи — це ті, які клієнт може динамічно запитувати під час
            перенаправлення на сторінку входу при використанні потоку <code>authorization_code</code>. Скоупи
            за замовчуванням завжди будуть додані до токенів, наприклад, для вирішення деяких проблем
            при використанні потоку <code>password</code>.`,
        },
        secret: {
            doCache: 'Кешувати секрет клієнта',
            cacheDuration: 'Тривалість кешування (години)',
            generate: 'Згенерувати новий секрет',
            rotateDesc1: `Щоб забезпечити плавне оновлення та ротацію секретів, ви маєте можливість зберігати
                поточний секрет у кеші в пам'яті на деякий час. Ви можете ввести значення від 1 до 24 годин.`,
            rotateDesc2: 'Увага: Не кешуйте поточний секрет, якщо стався його витік!',
        },
        tokenLifetime: {
            p1: `Час життя токена застосовується до токенів доступу (Access) та ID-токенів і вказується в секундах.`,
            p2: `Якщо клієнт підтримує алгоритми EdDSA / ed25519, їм завжди слід віддавати перевагу.
                Алгоритми RSA існують лише для сумісності.`,
            p3: `Алгоритм для refresh-токенів не може бути змінений, оскільки вони використовуються лише Rauthy.`,
        },
    },
    common: {
        account: 'Акаунт',
        addNew: 'Додати',
        back: 'Назад',
        caution: 'УВАГА',
        contact: 'Контакт',
        copiedToClip: 'Скопійовано до буферу обміну',
        details: 'Деталі',
        edit: 'Редагувати',
        enabled: 'Увімкнено',
        filter: 'Фільтр',
        from: 'Від',
        information: 'Інформація',
        language: 'Мова',
        loading: 'Завантаження',
        name: 'Назва',
        nameExistsAlready: 'Назва вже існує',
        note: 'Примітка',
        noEntries: 'Немає записів',
        preview: 'Попередній перегляд',
        reset: 'Скинути',
        searchOptions: 'Параметри пошуку',
        until: 'До',
    },
    docs: {
        book: 'Для загальної документації по Rauthy, перегляньте',
        encryption: 'Шифрування',
        encKeys: {
            header: 'Ключі шифрування',
            keyActive: 'Активний ключ',
            keysAvailable: 'Доступні ключі',
            migrate: 'Мігрувати',
            migrateToKey: 'Мігрувати всі існуючі зашифровані значення на наступний ключ',
            p1: `Ці ключі використовуються для додаткового шифрування "at rest" (у спокої), незалежно від
            технології сховища даних. Вони налаштовуються статично, але їх можна ротувати та мігрувати
            вручну на цій сторінці.`,
            p2: `Активний ключ статично встановлюється в конфігураційному файлі Rauthy / змінних середовища.
            Його не можна змінити тут динамічно. Усі нові JWK-шифрування завжди використовуватимуть
            поточний активний ключ.`,
            p3: `Якщо ви мігруєте всі існуючі секрети, це може зайняти кілька секунд, якщо у вас великий
            набір даних.`,
            pNotPossible:
                'Для можливості міграції має бути доступно щонайменше 2 ключі шифрування.',
        },
        hashing: {
            calculate: 'Розрахувати',

            currValuesHead: 'Поточні значення',
            currValues1: 'Поточні значення з бекенду наступні:',
            currValuesNote: `Примітка: Час входу з бекенду надає хороші орієнтири лише після щонайменше 5
            успішних входів, після запуску Rauthy. Базове значення завжди 2000 мс після свіжого перезапуску
            і буде коригуватися з часом з кожним успішним входом.`,
            currValuesThreadsAccess: 'Потоки (p_cost), до яких має доступ Rauthy',

            loginTimeHead: 'Кілька слів про час входу',
            loginTime1: `Загалом, користувачі хочуть, щоб усе було якомога швидше. Однак при безпечному вході,
            затримка в 500 - 1000 мс є прийнятною. Час входу не повинен бути занадто коротким,
            оскільки це, звісно, знизить криптографічну стійкість хешу.`,
            loginTime2: `Щоб забезпечити максимальну безпеку за замовчуванням, ця утиліта не дозволяє
            опускатися нижче 500 мс для часу входу.`,

            mCost1: `<code>m_cost</code> визначає кількість <b>пам'яті (в кБ)</b>, яка використовується для хешування.
            Чим вище значення, тим краще. Але потрібно враховувати ресурси сервера.<br>
            Наприклад, при одночасному хешуванні 4 паролів бекенду потрібно <code>4 x m_cost</code>
            пам'яті. Ці ресурси повинні бути доступні.`,
            mCost2: `Налаштування <code>m_cost</code> досить просте. Визначте максимальний обсяг пам'яті, який
            повинен використовувати Rauthy, поділіть його на кількість максимально дозволених паралельних
            входів (<code>MAX_HASH_THREADS</code>) і відніміть невеликий статичний обсяг пам'яті. Скільки
            статичної пам'яті враховувати, залежить від використовуваної бази даних та загальної кількості
            користувачів, але зазвичай це буде в діапазоні 32 - 96 МБ.`,
            mCost3: 'Мінімально дозволене значення <code>m_cost</code> — <code>32768</code>.',

            pCost1: `<code>p_cost</code> визначає рівень <b>паралелізму</b> для хешування. Це значення найчастіше
            не перевищує ~8, що є значенням за замовчуванням для Rauthy.`,
            pCost2: `Загальне правило:<br>
            Встановіть <code>p_cost</code> удвічі більшим за кількість доступних ядер.<br>
            Наприклад, якщо у вас є 4 ядра, встановіть <code>p_cost</code> на <code>8</code>.<br>
            Однак, це значення повинно враховувати налаштовану кількість дозволених паралельних входів
            (<code>MAX_HASH_THREADS</code>) і бути відповідно зменшеним.`,

            tCost1: `<code>t_cost</code> визначає <b>час</b> хешування. Це значення, по суті, єдине,
            що потребує тюнінгу, оскільки <code>m_cost</code> та <code>p_cost</code> в основному
            визначаються середовищем.`,
            tCost2: `Налаштування просте: встановіть <code>m_cost</code> та <code>p_cost</code> відповідно,
            а потім збільшуйте <code>t_cost</code>, доки не досягнете бажаного часу хешування.`,

            utilityHead: 'Утиліта для розрахунку параметрів',
            utility1: `Ви можете використовувати цей інструмент для приблизного визначення хороших значень для вашого
            середовища. Пам'ятайте, що його слід запускати, коли Rauthy вже розгорнуто з усіма фінальними
            ресурсами. Вам слід виконувати цю утиліту під навантаженням, щоб не перестаратися з налаштуваннями.`,
            utility2: `<code>m_cost</code> є необов'язковим, і буде обрано безпечне мінімальне значення <code>32768</code>,
            якщо поле порожнє. <code>p_cost</code> також необов'язковий, і Rauthy буде використовувати всі
            доступні йому потоки, якщо поле порожнє.`,

            time: 'Час',
            targetTime: 'Цільовий час',
            tune: 'Важливо: Ці значення потрібно налаштовувати на кінцевій архітектурі!',
            pDetials: `Якщо ви хочете детально ознайомитися з Argon2ID, в інтернеті є багато джерел. Ця
            інструкція дає лише дуже короткий огляд параметрів. Три з них потребують налаштування:`,
            pTune: `Вони змінюються залежно від можливостей системи. Чим потужніша система, тим
            надійнішими можуть бути ці значення.`,
            pUtility: `Ця утиліта допоможе вам знайти найкращі налаштування Argon2ID для вашої платформи.
            Argon2ID наразі є найнадійнішим доступним алгоритмом хешування паролів. Щоб використати
            його потенціал повною мірою, його потрібно налаштовувати для кожного розгортання.`,
        },
        openapi:
            'Якщо ви хочете інтегрувати зовнішній додаток і використовувати API Rauthy, перегляньте',
        openapiNote: `Залежно від конфігурації бекенду, Swagger UI може не бути доступним публічно.
            Однак, за замовчуванням він доступний через внутрішній HTTP-сервер метрик,
            щоб не розкривати жодної інформації.`,
        source: 'Вихідний код можна знайти тут',
    },
    editor: {
        bold: 'Жирний',
        code: 'Код',
        heading1: 'Заголовок 1',
        heading2: 'Заголовок 2',
        heading3: 'Заголовок 3',
        italic: 'Курсив',
        link: 'Посилання',
        listBullet: 'Маркований список',
        listTasks: 'Список завдань',
        listNumbered: 'Нумерований список',
        paragraph: 'Параграф',
        quote: 'Цитата',
        removeFmt: 'Прибрати форматування',
        strikeThrough: 'Закреслений',
        textArea: 'Редагувати текст',
    },
    email: {
        cancelJob: 'Скасувати завдання',
        filterType: ['Немає', 'В групі', 'Не в групі', 'Має роль', 'Не має ролі'],
        immediate: 'Негайно',
        jobs: 'Завдання E-Mail',
        scheduled: 'Запланована відправка',
        sendAllUsers: 'Цей E-Mail буде надіслано всім користувачам.',
        sendAllUsersFiltered: 'Цей E-Mail буде надіслано всім користувачам, відфільтрованим за:',
        sendMail: 'Надіслати E-Mail',
        subject: 'Тема',
        userFilter: 'Фільтр користувачів',
    },
    error: {
        needsAdminRole: `Вам не призначено роль <b>rauthy_admin</b>.<br/>
            Ви не маєте доступу до панелі адміністратора.`,
        noAdmin: `Акаунт адміна Rauthy повинен мати <b>увімкнене MFA.</b><br>
            Будь ласка, перейдіть до свого <b>акаунту</b> та активуйте MFA.<br>
            Після цього вам потрібно вийти і увійти знову.`,
    },
    events: {
        eventLevel: 'Рівень події',
        eventType: 'Тип події',
    },
    groups: {
        delete1: 'Дійсно видалити цю групу?',
        name: 'Назва групи',
    },
    jwks: {
        alg: 'Алгоритм',
        p1: 'Це Json Web Keys (JWKs), що використовуються для підпису токенів.',
        p2: `JWK будуть ротуватися за замовчуванням кожного 1-го числа місяця. Для всіх новостворених токенів
        для підпису буде використовуватися лише найновіший доступний ключ для даного алгоритму. Старі ключі
        зберігатимуться деякий час, щоб переконатися, що поточні дійсні токени все ще можуть бути
        належним чином перевірені. Через деякий час вони будуть автоматично видалені.`,
        p3: `Ключі також можна ротувати вручну. Залежно від заліза, на якому працює цей екземпляр Rauthy,
        це може зайняти кілька секунд.`,
        type: 'Тип',
        rotateKeys: 'Ротувати ключі',
    },
    nav: {
        apiKeys: 'API Ключі',
        attributes: 'Атрибути',
        blacklist: 'Чорний список',
        clients: 'Клієнти',
        config: 'Конфігурація',
        docs: 'Документація',
        events: 'Події',
        groups: 'Групи',
        providers: 'Провайдери',
        roles: 'Ролі',
        scopes: 'Скоупи',
        sessions: 'Сесії',
        users: 'Користувачі',
    },
    options: {
        expires: 'Дійсний до',
        lastSeen: 'Востаннє онлайн',
        state: 'Стан',
    },
    pam: {
        addGroup: 'Нова PAM група',
        addHost: 'Новий PAM хост',
        addUser: 'Новий PAM користувач',
        deleteHost: 'Ви справді хочете видалити цей хост?',
        groupDescGeneric: `Загальні групи є аналогом записів, що зазвичай знаходяться в /etc/group.
            Користувачів можна до них призначати, і вони повертаються системою через NSS Lookups.`,
        groupDescHost: `Групи хостів використовуються для групування хостів. NSS-запити хоста в межах групи
            повертають як результат усі інші хости в ній. Користувачі можуть отримувати доступ до хостів,
            призначаючи їх до групи хостів.`,
        groupDescLocal: `Локальні групи поводяться майже ідентично до Загальних груп, з тією різницею, що вони
            мають ID в базі даних Rauthy, але NSS-проксі на відповідному хості конвертує його в ID з
            /etc/group. Таким чином, користувачів Rauthy можна призначати до груп, які вже існують локально.`,
        groupDescUser: `Групи користувачів керуються автоматично і тісно пов'язані з користувачем з таким же
            іменем.`,
        groupDescWheel: `Ця група є особливою. Вона незмінна і призначається користувачам динамічно залежно від
            їхньої конфігурації груп.`,
        groupName: 'Назва групи',
        groups: 'Групи',
        groupType: 'Тип групи',
        hostAliases: 'Аліаси хоста',
        hostLocalPwdOnly: 'Вхід за локальним паролем',
        hostLocalPwdOnlyInfo: `Коли ввімкнено "Вхід за локальним паролем", це перевизначає "Примусове MFA"
            для локальних входів. Водночас, ключі доступу ніколи не запитуватимуться (локально) під час
            входів, навіть якщо користувач захищений MFA. Цю опцію слід вмикати лише в разі необхідності,
            наприклад, якщо користувачі з MFA повинні мати можливість входити локально, не використовуючи
            апаратні ключі доступу.`,
        ipAddresses: 'IP-адреси',
        member: 'Учасник',
        nameExistsAlready: "Ім'я вже зайняте",
        notes: 'Нотатки',
        secretShow: 'Показати секрет',
        secretRotate: 'Ротувати секрет',
        userEmail: "Прив'язаний E-Mail користувача",
        username: "Ім'я користувача",
        usernameNewDesc: `Ім'я користувача слід обирати уважно. Після створення його неможливо буде легко
            змінити з міркувань безпеки.`,
    },
    passwordPolicy: {
        configDesc: 'Політика для нових паролів.',
        resetSet0: 'Значення 0 деактивує вимогу.',
        validForDays: 'Дійсний (днів)',
        validityNew: 'Термін дії для нових паролів.',
    },
    providers: {
        config: {
            allowInsecureTls: 'Дозволити небезпечний TLS',
            autoLink: "Автоматична прив'язка",
            autoLinkDesc1: `Якщо активовано "Авто-прив'язку", вхід через цього провайдера автоматично прив'яже
                можливо існуючого, не прив'язаного користувача до цього провайдера.`,
            autoLinkDesc2: `УВАГА: Ця опція може бути дуже небезпечною і призвести до захоплення акаунта, якщо
                провайдер не перевіряє повністю адреси E-Mail для користувачів і, таким чином, дає
                можливість додати чужу адресу для користувача! НІКОЛИ не використовуйте в такому випадку!`,
            clientName: 'Назва клієнта',
            custRootCa: 'Власний кореневий CA (PEM)',
            descAuthMethod: `Метод автентифікації для ендпоінту <code>/token</code>.<br>
                Більшість провайдерів повинні працювати з <code>basic</code>, деякі — лише з <code>post</code>.
                У рідкісних ситуаціях вам можуть знадобитися обидва, хоча це може призвести до помилок з іншими.`,
            descClientId: 'ID клієнта, виданий провайдером.',
            descClientName: 'Назва клієнта, що буде показана на сторінці входу Rauthy.',
            descClientSecret: `Секрет клієнта, виданий провайдером.
                Потрібен щонайменше секрет клієнта або PKCE.`,
            descScope: `Скоуп, який клієнт повинен використовувати при перенаправленні на сторінку входу.
                Вкажіть значення через пробіл.`,
            errNoAuthMethod:
                'Ви вказали секрет клієнта, але не активували жодного методу автентифікації клієнта',
            errConfidential: 'Клієнт повинен бути конфіденційним або використовувати PKCE',
            jsonPath: {
                p1: 'Значення з ID-токена після успішного входу через зовнішнього провайдера можна автоматично зіставити.',
                p2: `<code>path</code> (шлях) має бути заданий у синтаксисі, подібному до regex. Він може вказувати
                    на окремі JSON-значення або на значення в JSON-об'єкті чи масиві.`,
                p3: "<code>$.</code> позначає початок JSON-об'єкта",
                p4: '<code>*</code> можна використовувати як шаблон у вашому шляху',
                p5: '<code>$.roles</code> вкаже на <code>&#123;"roles": "value"&#125;</code>',
                p6: `<code>$.roles.*</code> може вказувати на значення всередині об'єкта або масиву, наприклад:<br>
                    <code>&#123;"roles": ["value", "notMyValue"]&#125;</code>`,
            },
            lookup: 'Пошук',
            pathAdminClaim: 'Шлях до Admin Claim',
            pathMfaClaim: 'Шлях до MFA Claim',
            rootPemCert: 'Кореневий сертифікат (PEM)',
            mapMfa: `Якщо ваш провайдер видає claim, що вказує на те, що користувач використовував принаймні
                2FA під час входу, ви можете вказати шлях до mfa claim.`,
            mapUser: `Ви можете призначити користувача адміном Rauthy на основі клейму (claim) з ID-токена зовнішнього провайдера.`,
            valueAdminClaim: 'Значення Admin Claim',
            valueMfaClaim: 'Значення MFA Claim',
        },
        delete: {
            areYouSure: 'Дійсно видалити цього провайдера?',
            forceDelete: 'Примусове видалення',
            isInUse1: 'Цей провайдер використовується активними користувачами!',
            isInUse2: `Ви можете примусово видалити його, але користувачі без локального пароля або
                ключа доступу більше не зможуть увійти.`,
            linkedUsers: "Прив'язані користувачі",
        },
    },
    roles: {
        adminNoMod: 'Роль <code>rauthy_admin</code> є незмінною.',
        delete1: 'Дійсно видалити цю роль?',
        name: 'Назва ролі',
    },
    scopes: {
        defaultNoMod: 'Це стандартний OIDC скоуп. Вони є незмінними.',
        delete1: 'Дійсно видалити цей скоуп?',
        deleteDefault: 'Стандартні OIDC скоупи не можна видалити.',
        mapping1: 'Ви можете зіставляти власні скоупи з атрибутами.',
        mapping2: `Усі додаткові атрибути, що були налаштовані, можуть мати власне значення для кожного
            користувача. Коли вони прив'язані до скоупа, їх можна включити до токенів доступу
            (Access) та/або ID-токенів.`,
        name: 'Назва скоупа',
    },
    search: {
        orderBy: 'Сортувати за...',
        orderChangeToAsc: 'Сортувати за зростанням',
        orderChangeToDesc: 'Сортувати за спаданням',
    },
    sessions: {
        invalidateAll: 'Завершити всі сесії',
    },
    tabs: {
        config: 'Конфігурація',
        delete: 'Видалити',
    },
    tos: {
        accepted: 'Прийнято',
        addNewToS: 'Додати нові Умови користування',
        addNewToSFromCurrent: 'New ToS from template',
        added: 'Додано',
        checkStatus: 'Перевірити статус користувачів',
        immutable: `УВАГА: Додані Умови користування є незмінними, їх неможливо буде видалити!`,
        noneExist: 'Умови користування ще не додано.',
        optUntil: {
            desc: `Під час перехідного періоду прийняття оновлених Умов є добровільним. Після його закінчення — стане обовʼязковим.`,
            enable: 'Увімкнути перехідний період',
            label: 'Кінець перехідного періоду',
        },
        tos: 'Умови',
    },
    users: {
        antiLockout: {
            rule: 'Правило проти блокування',
            delete: 'не можна видалити',
            disable: 'не можна вимкнути',
            rauthyAdmin: 'правило rauthy_admin не можна видалити',
        },
        attributes: 'Атрибути',
        deleteUser: 'Дійсно видалити цього користувача?',
        descAttr: `Встановіть власні атрибути користувача. Усі пари ключ-значення обробляються як String / JSON Value.`,
        forceLogout: `Дійсно завершити всі існуючі сесії та видалити всі
            refresh-токени для цього користувача?`,
        lastLogin: 'Останній вхід',
        manualInitDesc: `Користувача також можна ініціалізувати тут, але в цьому випадку вам потрібно
            передати пароль особисто.`,
        manualInit: 'Ручна ініціалізація',
        mfaDelete1: 'Ви можете видалити ключі доступу (Passkeys) для цього користувача.',
        mfaDelete2: `Увага! Видалення ключа доступу <b>неможливо скасувати</b> без того, щоб
            користувач пройшов повну нову реєстрацію.`,
        noMfaKeys: 'У цього користувача немає зареєстрованих ключів доступу (Passkeys).',
        pkOnly1: 'Це акаунт, що використовує лише ключ доступу.',
        pkOnly2:
            'Це означає, що цей користувач використовує безпарольний вхід і взагалі не має встановленого пароля.',
        pkOnly3: `Якщо цей користувач втратив усі ключі доступу, акаунт можна повністю скинути, надіславши
            нового листа для відновлення пароля. Для цього перейдіть на вкладку 'MFA' та видаліть
            усі існуючі ключі доступу.`,
        pwdNoInit: 'Користувач ще не виконав початкове встановлення пароля.',
        pwdSendEmailBtn: 'Надіслати лист для відновлення',
        pwdSendEmailDesc:
            'Ви можете надіслати нового листа для відновлення, якщо користувач його не отримав.',
        savePassword: 'Зберегти пароль',
        selfServiceDesc:
            'Ви можете встановити новий пароль або надіслати листа для його відновлення.',
        sendResetEmail: 'Надіслати лист для відновлення',
    },
    validation: {
        css: 'Некоректне значення CSS',
        origin: 'Некоректний Origin',
        uri: 'Некоректний URI',
    },
};
