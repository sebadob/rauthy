import{u as t}from"./CwZgXZ6P.js";let n={api_key:{delete1:"Soll dieser API Key wirklich gelöscht werden?",expires:"Erlischt",generate1:"Hier kann ein neues Secret für diesen API Key generiert werden.",generate2:`Das Secret wird nur einmalig direkt nach dem Generieren angezeigt.
            Wenn ein Neues generiert wurde, wird das Alte unmittelbar, permanent überschrieben.
            Diese Operation kann nicht rückgängig gemacht werden!`,generate3:`Der API Key muss im HTTP <code>Authorization</code> Header im folgenden
            Format mitgegeben werden:`,generate4:"Der folgende <code>curl</code> request kann zum Testen des Keys verwendet werden:",generate5:"Sollte <code>jq</code> nicht installiert sein, hier eine Version ohne:",keyName:"Key Name",limitedValidity:"Begrenzte Gültigkeit"},attrs:{delete1:"Soll dieses Attribut wirklich gelöscht werden?",desc:"Beschreibung",name:"Attribut Name"},clients:{backchannelLogout:"Sollte dieser client {{ OIDC_BCL }} unterstützen, kann die URI hier angegeben werden.",branding:{descHsl:`Die folgenden Werte müssen als HSL angegeben werden. Hier wird nur die Basis-Farbe
                definiert. Alpha Kanäle und andere Werte werden vom Theme dynamisch angepasst.`,descFullCss:`Die folgenden Werte müssen vollständig gültige Angaben für CSS <code>color</code> sein.
                Es können auch komplexe Kalkulationen oder die oben definierten CSS Variables 
                genutzt werden.`,descVariables:`Jede nachfolgende Beschriftung ist gleichzeitig der Name der CSS Variable. Das heisst,
                dass z.B. die freien Eingaben wiederum die Variablen referenzieren können, z.B. mit
                <code>hsla(var(--action) / .7)</code>.`},confidential:"Vertraulich",confidentialNoSecret:"Dies is kein vertraulicher Client und hat somit kein Secret.",config:"Client Konfiguration",delete1:"Soll dieser Client wirklich gelöscht werden?",descAuthCode:`Die Gültigkeit der Auth Codes kann angepasst werden um zusätzliche Sicherheit
            zu gewinnen. Auth Codes können nur einmalig verwendet werden und sind normalerweise für 60
            Sekunden gültig. Je kürzer, desto besser, so lange der Client den Code schnell genug nutzen kann.`,descClientUri:`Informationen über URI und Kontakte dieses Clients zur Anzeige
            auf der Login Seite.`,descName:`Der Client Name kann geändert werden ohne Einfluss auf die Konfiguration.
            Er dient lediglich der Anzeige auf der Login Seite.`,descOrigin:`Externe, zusätzlich erlaubte Origins - normalerweise nur notwendig, wenn dieser 
            Client direkt aus dem Browser heraus Requests zu Rauthy machen muss, typischerweise SPAs.`,descPKCE:`Wenn der Client Support für PKCE hat, sollte zur zusätzlichen Sicherheit immer S256 
            PKCE aktiviert werden. Wenn ein nicht-vertraulicher Client (z.B. eine SPA) genutzt wird, muss
            mindestens eine PKCE Challenge aktiviert sein, um ausreichend Sicherheit bieten zu können.`,descPKCEEnforce:`Wenn PKCE aktiviert ist, erzwingt Rauthy die Nutzung and verweigert Logins,
            die keine korrekte Challenge bereit stellen.`,descUri:`Es können beliebig viele Redirect URIs angegeben werden. Am Ende einer Jeden wird 
            optional <code>*</code> als Wildcard akzeptiert.`,errConfidentialPKCE:`Der Client muss entweder vertraulich sein oder mindestens eine PKCE
            Challenge aktiviert haben.`,forceMfa:"MFA Erzwingen",name:"Client Name",scim:{baseUri:`Die SCIM base URI muss jene sein, von der Sub-Routen wie 
                <code>{base_uri}/Users/{id}</base_uri></code> korrekt abgeleitet werden können.`,desc:"Sollte dieser client {{ SCIM_LINK }} unterstützen, kann es hier aktiviert werden.",enable:"SCIMv2 aktivieren",groupSync:"Gruppen synchronisieren",groupSyncPrefix:"Gruppen Filter Prefix",groupSyncPrefixDesc:`Die zu synchronisierenden Gruppen können per optionalem Prefix gefiltert werden.
                Wenn z.B. Gruppen wie <code>app:admins</code> und <code>app:users</code> existieren, würde das
                Prefix <code>app:</code> dafür sorgen, dass nur diese Gruppen synchronisiert werden, wie auch nur
                jene Benutzer, die zu mindestens einer dieser Gruppen gehören.`,reqDesc:"Es gibt folgende Bedingungen für die Kompaibilität:",reqLi1:"Der client muss <code>externalId</code> korrekt handhaben.",reqLi2:`Mindestens die <code>/Users</code> endpunkte mit <code>filter=externalId eq "*"</code> und
                <code>filter=userName eq "*"</code> müssen unterstützt sein.`,reqLi3:`Wenn Gruppen sychronisiert werden sollen, so müssen unter <code>/Groups</code> zusätzlich 
                <code>filter=displayName eq "*"</code> unterstützt sein.`},scopes:{allowed:"Erlaubte Scopes",default:"Standard Scopes",desc:`Erlaubte Scopes sind diejenigen, die der Client dynamisch beim Redirect zum Login
            im <code>authorization_code</code> flow anfordern kann. Die standard Scopes werden hingegen immer
            hinzugefügt und können Probleme lösen, wenn z.B. der <code>password</code> Flow verwendet
            wird.`},secret:{doCache:"Client Secret cachen",cacheDuration:"Cache Dauer (Stunden)",generate:"Neues Secret Generieren",rotateDesc1:`Um unterbrechungsfreie Updates durchfürhen zu können, ist es möglich, das bestehende Secret
                für eine gewisse Zeit im in-memory Cache zu behalten. Es kann ein Wert zwischen 1 und 24 Stunden 
                angegeben werden.`,rotateDesc2:"Achtung: Das derzeitige Secret sollte nicht im Cache behalten werden, wenn es ein Leak gab!"},tokenLifetime:{p1:"Die Token Lifetime wird auf Access und ID Tokens angewandt und wird in Sekunden angegeben.",p2:`Sollte der Client EdDSA / ed25519 Algorithmen unterstützen, sollte dies die bevorzugte Wahl
                sein. RSA Algorithmen existieren lediglich aus Kompatibilitätsgründen.`,p3:`Der Algorithmus für Refresh Tokens kann nicht geändert werden, da diese nur von Rauthy
                genutzt werden sollten.`}},common:{account:"Account",addNew:"Neu Hinzufügen",back:"Zurück",contact:"Kontakt",copiedToClip:"Wert wurde in die Zwischenablage kopiert",details:"Details",edit:"Bearbeiten",enabled:"Aktiviert",filter:"Filter",from:"Von",information:"Informationen",language:"Sprache",loading:"Lade",name:"Name",nameExistsAlready:"Name existiert bereits",note:"Notiz",noEntries:"Keine Einträge",reset:"Zurücksetzen",search:"Suchen",searchOptions:"Suchoptionen",until:"Bis"},docs:{book:"Für generelle Dokumentation für Rauthy existiert das",encryption:"Verschlüsselung",encKeys:{header:"Encryption Keys",keyActive:"Aktiver Key",keysAvailable:"Verfügbare Keys",migrate:"Migrieren",migrateToKey:"Migriere alle Werte zu folgendem Encryption Key",p1:`Diese Schlüssel werden für die zusätzliche Verschlüsselung in verschiedenen Situationen genutzt, wie 
            z.B. gewisse Werte innerhalb der Datenbank oder Session Cookies. Sie sind statisch konfiguriert, aber können
            als best-practice manuell rotiert werden.`,p2:`Der aktive Schlüssel ist ebenfalls statisch im Rauthy config file gesetzt. Alle neu-verschlüsselten
            Werte werden mit dem aktiven Schlüssel verschlüsselt, während alte zur Rückwärts-Kompatibilität parallel
            existieren können.`,p3:`Das Migrieren aller verschlüsselten Werte an dieser Stelle kann, je nach System, einige Zeit in 
            Anspruch nehmen.`,pNotPossible:"Zur Migration müssen mindestens 2 Encryption Keys vorhanden sein."},hashing:{calculate:"Berechnen",currValuesHead:"Derzeitige Werte",currValues1:"Die derzeitigen im Backend konfigurierten Werte sind die folgenden:",currValuesNote:`Notiz: Die Login Zeit vom Backend wird nur dann eine gute Richtlinie sein, nachdem 
            mindestens 5 erfolgreiche Logins seit dem letzten Neustart gemacht wurden. Der Ausgangswert ist immer 
            2000 ms und wird mit jedem erfolgreichen Login neu gemittelt.`,currValuesThreadsAccess:"Threads (p_cost) die Rauthy zur Verfügung stehen",loginTimeHead:"Ein paar Worte zur Login Zeit",loginTime1:`Generell möchten User alles so schnell wie möglich. Für eine sichere Login Prozedur jedoch
            sollte mindestens eine Dauer von 500 - 1000 ms anvisiert werden and kein Problem darstellen. Die Zeit zum
            Passwort Hashing darf nicht zu kurz gewählt werden, weil dadurch die Stärke des Hashes reduziert werden 
            würde.`,loginTime2:`Um standardmäßig genügend Sicherheit zu gewährleisten, erlaubt dieses Tool keine kleineren
            Werte als 500 ms für die Login Zeit.`,mCost1:`Die <code>m_cost</code> definiert die Menga an <b>Speicher (in kB)</b> die zum Hashing verwendet
            wird. Je höher dieser Wert, umso besser (sicherer), aber die notwendigen Ressourcen müssen natürlich 
            vorhanden sein.<br>
            Wenn z.B. 4 Passwörter zur selben Zeit gehasht werden, wird selbstverständlich <code>4 x m_cost</code>
            an Speicher benötigt, was zu jeder Zeit zur Verfügung stehen muss.`,mCost2:`Den "richtigen" Wert für <code>m_cost</code> zu finden ist glücklicherweise sehr einfach. Definiere
            das Maximum an Speicher, das Rauthy nutzen sollte, dividiere die Menge durch die Anzahl paralleler Logins, 
            die möglich sein sollten (<code>MAX_HASH_THREADS</code>) und ziehe hier von eine gewisse statische Menge ab.
            Die Höhe des statisch benötigten Speichers hängt von der gewählten Datenbank und Anzahl Benutzer ab, jedoch
            wird sie in den meisten Fällen im Bereich von 32 - 96 MB sein.`,pCost1:`<code>p_cost</code> definiert den Parallelismus fürs Hashing.<br>
            In den meisten Fällen erhöhen Werte jenseits von 8 nichts mehr die benötigte Zeit, weil der Algorithmus
            gesättigt sein wird. Dies ist auch der Standardwert für Rauthy.`,pCost2:`Die generelle Regel lautet:<br>
            Setze <code>p_cost</code> auf den zweifachen Wert der verfügbares CPU Kerne.<br>
            Wenn z.B. 4 Kerne zur Verfügung stehen, wäre eine <code>p_cost</code> von 8 ein guter Wert.<br>
            Der Wert muss allerdings die maximale Anzahl parallel erlaubter Logins (<code>MAX_HASH_THREADS</code>) 
            berücksichtigen und ggf. entsprechend reduziert werden.`,tCost1:`<code>t_cost</code> ist ein Multiplikator für die <b>Zeit</b> fürs Hashing. Dies ist der einzige
            Wert, der durch Testen auf der Zielarchitektur gefunden werden muss, weil <code>m_cost</code> und 
            <code>p_cost</code> gewissenermaßen vorgegeben sind.`,tCost2:`Das Finden des Wertes ist einfach: Setze <code>m_cost</code> und <code>p_cost</code> wie oben
            erklärt und erhöhe <code>t_cost</code> so lange, bis die gewünschte Login Zeit erreicht wird.`,utilityHead:"Parameter Berechnungs-Werkzeug",utility1:`Das folgende Werkzeug kann zum Finden passender Werte für dieses Rauthy deployment genutzt 
            werden. Da die Werte von sehr vielen Faktoren abhängen, sollten dieser auf der finalen Architektur 
            eingestellt werden, am besten zu Zeiten der am höchsten erwarteten Last, um keine zu hohen Werte 
            einzustellen.`,utility2:`<code>m_cost</code> ist Optional und der als minimal sichere Wert von 32768 würde automatisch
            gewählt werden. Sollte <code>p_cost</code> ebenfalls nicht gegeben sein, so wird Rauthy die maximal 
            verfügbare Menge and Kernen nutzen.`,time:"Zeit",targetTime:"Ziel-Zeit",tune:"Wichtig: Diese Werten müssen auf der finalen Architektur eingestellt werden!",pDetials:`Für eine detailiertere Einführung in den Argon2ID Alrogithmus stehen vielen Quellen online zur
            Verfügung. Hier werden nur ganz kurz die Werte erklärt. Die folgenden drei Werte müssen konfiguriert werden:`,pTune:`Die Werte können stark variieren in Abhängigkeit vom System und der generellen Systemlast. Je 
            stärker das System, desto sicherere Werte können gewählt werden.`,pUtility:`Dieses Werkzeug ist eine Hilfe zum Finden der besten Argon2ID Werte für das jeweilige System.
            Argon2ID is der derzeit sicherste, verfügbare Passwort Hashing Algorithmus. Um das volle Potential 
            ausschöpfen zu können, müssen die Werte allerdings auf das System angepasst werden.`,mCost3:"Der minimal erlaubte Wert für <code>m_cost</code> ist <code>32768</code>."},openapi:"Zur Integration einer externen Applikation via Rauthy's API gibt es das",openapiNote:`In Abhängigkeit von der Konfiguration ist das Swagger  UI nicht öffentlich zugänglich übber den
            oben genannten Link. Es ist allerdings (standardmäßig) über den internen metrics server verfügbar zur
            Reduzierung der Angriffsfläche.`,source:"Der source code kann hier gefunden werden"},error:{needsAdminRole:"Um Zugriff zu erhalten ist die Rolle <b>rauthy_admin</b> notwendig.",noAdmin:`Für Rauthy Admin Accounts ist <b>MFA Pflicht.</b><br>
            Im <b>Account</b> kann ein Passkey hinterlegt und MFA aktiviert werden.<br>
            Danach muss ein Logout und neuer Login folgen`},events:{eventLevel:"Event Level",eventType:"Event Typ"},groups:{delete1:"Soll diese Gruppe wirklich gelöscht werden?",name:"Gruppenname"},jwks:{alg:"Algorithmus",p1:"Dies sind die Json Web Keys (JWKs) die für das Signieren der Tokens genutzt werden.",p2:`JWKs werden standardmäßig automatisch an jedem 1. des Monats rotiert. Für alle neuen Tokens wird 
        immer die aktuellste Version eines Keys für den jeweiligen Algorithmus verwerndet. Alte Keys werden für 
        eine Weile behalten um bestehende Tokens validieren zu können und nach einer gewissen Zeit automatisch gelöscht.`,p3:`Die Keys können manuell rotiert werden. Abhängig von der Hardware auf der diese Rauthy Instanz läuft,
        kann dies einige Sekunden in Anspruch nehmen.`,type:"Typ",rotateKeys:"Keys Rotieren"},nav:{apiKeys:"API Keys",attributes:"Attribute",blacklist:"Blacklist",clients:"Clients",config:"Konfiguration",docs:"Dokumentation",events:"Events",groups:"Gruppen",providers:"Provider",roles:"Rollen",scopes:"Scopes",sessions:"Sessions",users:"Benutzer"},options:{expires:"Erlischt",lastSeen:"Zuletzt Gesehen",state:"Status"},passwordPolicy:{configDesc:"Regeln für neue Passwörter.",resetSet0:"Der Wert 0 deaktiviert die Bedingung.",validForDays:"Gültigkeit Tage",validityNew:"Gültigkeit für neue Passwörter."},providers:{config:{allowInsecureTls:"Erlaube unsicheres TLS",clientName:"Client Name",custRootCa:"Eigenes Root CA PEM",descAuthMethod:`Die Authentication Method, welche für den <code>/token</code> Endpunkt genutzt werden soll.
                Die meisten Provider sollten mit <code>basic</code> funktionieren, manche jedoch nur mit 
                <code>post</code>. In seltenen Fällen müssen beide Optionen aktiviert werden, auch wenn es gegen das
                RFC verstößt.`,descClientId:"Client ID, vom Auth Provider vorgegeben.",descClientName:"Client Name der auf der Rauthy Login Form angezeigt werden soll.",descClientSecret:`Client Secret, vom Auth Provider vorgegeben.
                Es muss mindestens ein Secret gegeben, oder PKCE aktiviert sein.`,descScope:`Der scope der beim Redirect zum Login genutzt werden soll. Werte müssen durch Leerzeichen
                getrennt angegeben werden`,errNoAuthMethod:"Ein client secret existiert, jedoch ist keine auth Methode aktiv",errConfidential:"Es muss mindestens entweder ein client secret existieren oder PKCE aktiv sein.",jsonPath:{p1:"Werte aus dem ID Token nach einem erfolgreichen Upstream Login können automatisch gemapped werden.",p2:`Der <code>Pfad</code> muss in korrekter Regex Syntax angegeben werden. Er kann auf einzelne JSON
                    Werte verweise, oder komplexe Sturkturen wie Arrays oder Objects`,p3:"<code>$.</code> markiert den Beginn eines JSON Objects",p4:"<code>*</code> kann als Wildcard innerhalb des Pfads genutzt werden",p5:'<code>$.roles</code> hätte als Ziel den Wert <code>&#123;"roles": "value"&#125;</code>',p6:`<code>$.roles.*</code> kann auf einen Wert innerhalb eines Arrays oder Objects wie z.B.<br>
                    <code>&#123;"roles": ["value", "notMyValue"]&#125;</code> verweisen`},lookup:"Prüfen",pathAdminClaim:"Admin Claim Pfad",pathMfaClaim:"MFA Claim Pfad",rootPemCert:"Root PEM Zertifikat",mapMfa:`Sollte der Auth Provider in ID Claim bereit stellen, welches anzeigt, ob eine Art 2FA oder MFA
                beim Login verwandt wurde, so kann Rauthy diesen Werten extrahieren und entsprechend weitergeben.`,mapUser:`Es kann beim Login automatisch ein Nutzer mit der Rauthy Admin Rolle verlinkt werden, in
                Abhängigkeit von einem existierenden Upstream ID Claim.`,valueAdminClaim:"Admin Claim Wert",valueMfaClaim:"MFA Claim Wert"},delete:{areYouSure:"Sicher, dass dieser Provider gelöscht werden soll?",forceDelete:"Löschen Erzwingen",isInUse1:"Dieser Provider wird von aktiven Nutzern verwendet!",isInUse2:`Das Löschen kann erzwungen werden. Nutzer ohne lokales Passwort oder
                Passkey werden jedoch nicht mehr in der Lage sein, sich einzuloggen.`,linkedUsers:"Verbundene Nutzer"}},roles:{adminNoMod:"Die <code>rauthy_admin</code> Rolle kann nicht verändert werden.",delete1:"Soll diese Rolle wirklich gelöscht werden?",name:"Rollenname"},scopes:{defaultNoMod:"Dies ist ein Default OIDC Scope. Diese sind unveränderbar.",delete1:"Soll dieser Scope wirklich gelöscht werden?",deleteDefault:"OIDC default scopes cannot be deleted",mapping1:"Benutzer Attribute können auf eigene Scopes gemapped werden.",mapping2:`Jedes existierende Attribut hat einen eigenständigen Wert pro User. Diese Attribute können
            auf einen Scope gemapped werden und werden in diesem Fall im Access bzw. ID Token enthalten sein.`,name:"Scope Name"},sessions:{invalidateAll:"Alle Sessions Invalidieren"},search:{orderBy:"Sortieren nach ...",orderChangeToAsc:"Zu aufsteigender Sortierung wechseln",orderChangeToDesc:"Zu absteigende Sortierung wechseln"},tabs:{config:"Konfiguration",delete:"Löschen"},users:{attributes:"Attribute",deleteUser:"Soll dieser Benutzer wirklich gelöscht werden?",descAttr:`Setze individuelle Benutzer Attribute. Alle Key / Value Paare 
            werden als String / JSON Wert gehandhabt.`,forceLogout:`Sollen sämtliche, für diesen Benutzer existierenden Sessions invalidiert und 
            Refresh Tokens gelöscht werden?`,lastLogin:"Letzter Login",manualInitDesc:`Der Benutzer kann jedoch ebenfalls hier initialisiert werden. In diesem Fall muss das
            Passwort allerdings direkt kommuniziert werden.`,manualInit:"Manuell Initialisieren",mfaDelete1:"Die Passkeys dieses Nutzers können gelöscht werden.",mfaDelete2:`Vorsicht! Das Löschen eines Keys <b>kann nicht rückgängig gemacht werden</b>, ohne
            dass der Benutzer die Registrierung erneut durchführt.`,noMfaKeys:"Dieser Benutzer hat keine registrierten Passkeys.",pkOnly1:"Dies ist ein Passkey-Only Account.",pkOnly2:"Das bedeutet, dass dieser Benutzer den passwortlosen Login nutzt und kein Passwort gesetzt hat.",pkOnly3:`Sollte dieser Benutzer alle Passkeys verloren haben, kann der Account vollständig resettet und eine
            Password Reset E-Mail versendet werden. Um dies zu tun, müssen vorher unter dem Reiter 'MFA' sämtliche
            Passkeys gelöscht werden.`,pwdNoInit:"Der Benutzer hat noch nicht den initialien Passwort Reset durchgeführt.",pwdSendEmailBtn:"Reset E-Mail Senden",pwdSendEmailDesc:"Es kann eine neue Reset E-Mail gesendet werden, sollte der Benutzer keine erhalten haben.",savePassword:"Passwort Speichern",selfServiceDesc:"Es kann entweder ein neues Passwort gesetzt, order eine Reset E-Mail versendet werden.",sendResetEmail:"Reset E-Mail Senden"},validation:{css:"Gültiger CSS Wert",origin:"Gültige Origin",uri:"Gültige URI"}},i={api_key:{delete1:"Are you sure, that you want to delete this API Key?",expires:"Expiry",generate1:"Here you can generate a new secret for this API Key.",generate2:`You will only see this secret once after the generation.
            When a new one has been generated, the old secret will be overridden permanently.
            This operation cannot be reverted!`,generate3:`An API Key must be provided in the HTTP <code>Authorization</code>
            header in the following format:`,generate4:"You can use the following <code>curl</code> request to test your new Key:",generate5:"If you don't have <code>jq</code> installed and the above fails:",keyName:"Key Name",limitedValidity:"Limited Validity"},attrs:{delete1:"Are you sure you want to delete this attribute?",desc:"Description",name:"Attribute Name"},clients:{backchannelLogout:"If this client supports {{ OIDC_BCL }}, you can provide the URI here.",branding:{descHsl:`The following values must be given as HSL values. You only provide the base colors.
            Alpha channels and other values are manipulated dynamically by the theme.`,descFullCss:`The following values must be fully valid CSS <code>color</code> values.
                You can also use complex calculations or the above defined CSS variables.`,descVariables:`Each following label is at the same time the name of the CSS variable. This means,
                that you can reference these in the free inputs, e.g. with <code>hsla(var(--action) / .7)</code>.`},confidential:"Confidential",confidentialNoSecret:"This is a non-confidential client and therefore has not secret.",config:"Client Configuration",delete1:"Are you sure you want to delete this client?",descAuthCode:`The validity for auth codes can be adjusted for increased security. Auth codes
            can be used only once and are valid for 60 seconds by default. The shorter the validity, the
            better, as long as the client can perform the login procedure fast enough.`,descClientUri:`Information about this clients URI and contacts to be shown on
            the login page.`,descName:`The client name can be changed without any impact on the client configuration.
            It only exists to be shown on the login page.`,descOrigin:`External, additionally allowed origins - usually only necessary, if this client
            needs to make requests to Rauthy directly from the browser, typically SPAs.`,descPKCE:`If the client supports it, you should always activate S256 PKCE for additional 
            security. If a non-confidential client (e.g. a SPA) is being used, you must at least 
            activate one of the PKCE challenges to have enough security.`,descPKCEEnforce:`If any PKCE is activated, Rauthy will enforce the usage during Logins, and
            rejects login request that do not contain a valida challenge.`,descUri:`You can provide as many redirect URIs as you like. At the end of each, you can use 
            <code>*</code> as a Wildcard.`,errConfidentialPKCE:`The client must either be confidential or have at least one PKCE
            challenge activated.`,forceMfa:"Force MFA",name:"Client Name",scim:{baseUri:`The SCIM base URI is the one from which the sub routes like 
                <code>{base_uri}/Users/{id}</base_uri></code> can be derived correctly.`,desc:"If this client supports {{ SCIM_LINK }}, you can activate it here.",enable:"Enable SCIMv2",groupSync:"Synchronize Groups",groupSyncPrefix:"Groups Filter Prefix",groupSyncPrefixDesc:`You can filter the groups for the synchronization by an optional prefix.
                For instance, if the groups <code>app:admins</code> and <code>app:users</code> exist, the prefix
                 <code>app:</code> would only sync these groups, as well as only those users that are linked to at least
                 one of these groups.`,reqDesc:"A few things are required for compatibility:",reqLi1:"The client must handle <code>externalId</code> correctly.",reqLi2:`At least <code>/Users</code> endpoints with <code>filter=externalId eq "*"</code> and
                <code>filter=userName eq "*"</code> must be supported.`,reqLi3:`If groups should be synchronized, <code>/Groups</code> must also support 
                <code>filter=displayName eq "*"</code>.`},scopes:{allowed:"Allowed Scopes",default:"Default Scopes",desc:`Allowed Scopes are the ones the client is allowed to request dynamically during
            a redirect to the login when using the <code>authorization_code</code> flow. The default
            scopes will always be added to the tokens to solve some issues when using the 
            <code>password</code> for instance.`},secret:{doCache:"Cache Client Secret",cacheDuration:"Cache Duration (hours)",generate:"Generate New Secret",rotateDesc1:`To make graceful updates and secret rotations possible, you have the ability to keep the
                current secret in an in-memory cache for some time. You can enter a value between 1 and 24 hours.`,rotateDesc2:"Caution: You should not cache the current secret if you had a leak!"},tokenLifetime:{p1:"The token lifetime applies to Access and ID tokens and is given in seconds.",p2:`If the client supports EdDSA / ed25519 algorithms, it should always be the preferred
                choice. RSA algorithms exist for compatibility only.`,p3:"The algorithm for refresh tokens cannot be changed, since these are used by Rauthy only."}},common:{account:"Account",addNew:"Add New",back:"Back",contact:"Contact",copiedToClip:"Value has been copied to clipboard",details:"Details",edit:"Edit",enabled:"Enabled",filter:"Filter",from:"From",information:"Information",language:"Language",loading:"Loading",name:"Name",nameExistsAlready:"Name exists already",note:"Note",noEntries:"No Entries",reset:"Reset",search:"Search",searchOptions:"Search Options",until:"Until"},docs:{book:"For general documentation about Rauthy itself, you should take a look at the",encryption:"Encryption",encKeys:{header:"Encryption Keys",keyActive:"Active Key",keysAvailable:"Available Keys",migrate:"Migrate",migrateToKey:"Migrate all existing encrypted values to the following key",p1:`These Keys are used for an additional encryption at rest, independently from any data store technology 
            used under the hood. They are configured statically, but can be rotated and migrated on this page manually.`,p2:`The active key is statically set in the Rauthy config file / environment variables. It cannot be changed
            here dynamically. All new JWK encryption's will always use the currently active key.`,p3:`If you migrate all existing secrets, it might take a few seconds to finish, if you have a big 
            dataset.`,pNotPossible:"To be able to migrate, at least 2 encryption keys need to be available."},hashing:{calculate:"Calculate",currValuesHead:"Current values",currValues1:"The current values from the backend are the following:",currValuesNote:`Note: The Login Time from the backend does only provide a good guideline after at least 5 
            successful logins, after Rauthy has been started. The base value is always 2000 ms after a fresh restart 
            and will adjust over time with each successful login.`,currValuesThreadsAccess:"Threads (p_cost) Rauthy has access to",loginTimeHead:"A word about Login Time",loginTime1:`Generally, users want everything as fast as possible. When doing a safe login though, a time 
            between 500 - 1000 ms should not be a problem. The login time must not be too short, since it would lower 
            the strength of the hash, of course.`,loginTime2:`To provide as much safety by default as possible, this utility does not allow you to go below 
            500 ms for the login time.`,mCost1:`The <code>m_cost</code> defines the amount of <b>memory (in kB)</b>, which is used for the hashing.
            The higher the value, the better, of course. But you need to keep in mind the servers resources.<br>
            When you hash 4 passwords at the same time, for instance, the backend needs <code>4 x m_cost</code>
            during the hashing. These resources must be available.`,mCost2:`Tuning <code>m_cost</code> is pretty easy. Define the max amount of memory that Rauthy should use,
            divide it by the number of max allowed parallel logins (<code>MAX_HASH_THREADS</code>) and subtract a small 
            static amount of memory. How much static memory should be taken into account depends on the used database
            and the total amount of users, but will typically be in the range of 32 - 96 MB.`,mCost3:"The minimal allowed <code>m_cost</code> is <code>32768</code>.",pCost1:`The <code>p_cost</code> defines the amount of <b>parallelism</b> for hashing. This value most often 
            tops out at ~8, which is the default for Rauthy.`,pCost2:`The general rule is:<br>
            Set the <code>p_cost</code> to twice the size of cores your have available.<br>
            For instance, if you have 4 cores available, set the <code>p_cost</code> to <code>8</code>.<br>
            However, this value must take the configured allowed parallel logins (<code>MAX_HASH_THREADS</code>) into
            account and be reduced accordingly.`,tCost1:`The <code>t_cost</code> defines the amount of <b>time</b> for hashing. This value is actually the 
            only value, that needs tuning, since <code>m_cost</code> and <code>p_cost</code> are basically given by the 
            environment.`,tCost2:`Tuning is easy: Set <code>m_cost</code> and <code>p_cost</code> accordingly and then increase
            <code>t_cost</code> as long as you have not reached your hashing-time-goal.`,utilityHead:"Parameter Calculation Utility",utility1:`You can use this tool to approximate good values for your deployment. Keep in mind, that this 
            should be executed with Rauthy in its final place with all final resources available. You should execute 
            this utility during load to not over tune.`,utility2:`<code>m_cost</code> is optional and the safe minimal value of <code>32768</code> would be chosen, 
            if empty. <code>p_cost</code> is optional too and Rauthy will utilize all threads it can see, if empty.`,time:"Time",targetTime:"Target Time",tune:"Important: These values need to be tuned on the final architecture!",pDetials:`If you want a detailed introduction to Argon2ID, many sources exist online. This guide just 
            gives very short overview about the values. Three of them need to be configured:`,pTune:`They change depending on the capabilities of the system. The more powerful the system, the more safe 
            these values can be.`,pUtility:`This utility helps you find the best Argon2ID settings for your platform.
            Argon2ID is currently the safest available password hashing algorithm. To use it to its fullest potential, 
            it has to be tuned for each deployment.`},openapi:"If you want to integrate an external application and use Rauthy's API, take a look at the",openapiNote:`Depending on the backend configuration, the Swagger UI may not be exposed publicly at this point.
            It is however by default available via the internal metrics HTTP server to not expose any 
            information.`,source:"The source code can be found here"},error:{needsAdminRole:`You are not assigned to the <b>rauthy_admin</b> role.<br/>
            You do not have access to the admin panel.`,noAdmin:`A Rauthy admin account must have <b>MFA enabled.</b><br>
            Please navigate to your <b>account</b> and activate MFA.<br>
            Afterward, you need to do a logout and log back in.`},events:{eventLevel:"Event Level",eventType:"Event Type"},groups:{delete1:"Are you sure you want to delete this group?",name:"Group Name"},jwks:{alg:"Algorithm",p1:"These are the Json Web Keys (JWKs) used for token singing.",p2:`The JWKs will be rotated by default every 1st of a month. For all newly created tokens, only the latest
        available key for the given algorithm will be used for signing. Old keys will be kept for a while to make sure
        that currently valid tokens can still be validated properly. After a while, they will be cleaned up 
        automatically.`,p3:`Keys can also be rotated manually. Depending on the hardware this Rauthy instance is running on, it might
        take a few seconds.`,type:"Type",rotateKeys:"Rotate Keys"},nav:{apiKeys:"API Keys",attributes:"Attributes",blacklist:"Blacklist",clients:"Clients",config:"Config",docs:"Docs",events:"Events",groups:"Groups",providers:"Providers",roles:"Roles",scopes:"Scopes",sessions:"Sessions",users:"Users"},options:{expires:"Expires",lastSeen:"Last Seen",state:"State"},passwordPolicy:{configDesc:"Policy for new passwords.",resetSet0:"The value 0 deactivates the requirement.",validForDays:"Valid For Days",validityNew:"Validity for new passwords."},providers:{config:{allowInsecureTls:"Allow insecure TLS",clientName:"Client Name",custRootCa:"Custom Root CA PEM",descAuthMethod:`The authentication method to use on the <code>/token</code> endpoint.<br>
                Most providers should work with <code>basic</code>, some only with <code>post</code>.
                In rare situations, you need both, while it can lead to errors with others.`,descClientId:"Client ID given by the auth provider.",descClientName:"Client name that should be shown on the Rauthy login page.",descClientSecret:`Client Secret given by the auth provider.
                At least a client secret or PKCE is required.`,descScope:`The scope the client should use when redirecting to the login.
                Provide the values separated by space.`,errNoAuthMethod:"You have given a client secret, but no client auth method is active",errConfidential:"Must at least be a confidential client or use PKCE",jsonPath:{p1:"Values from the ID token after a successful upstream login can be mapped automatically.",p2:`The <code>path</code> needs to be given in a regex like syntax. It can resolve to
                    single JSON values or resolve to a value in a JSON object or array.`,p3:"<code>$.</code> marks the start of the JSON object",p4:"<code>*</code> can be used as a wildcard in your path",p5:'<code>$.roles</code> would target <code>&#123;"roles": "value"&#125;</code>',p6:`<code>$.roles.*</code> can target a value inside an object or array like<br>
                    <code>&#123;"roles": ["value", "notMyValue"]&#125;</code>`},lookup:"Lookup",pathAdminClaim:"Admin Claim Path",pathMfaClaim:"MFA Claim Path",rootPemCert:"Root PEM Certificate",mapMfa:`If your provider issues a claim indicating that the user has used at least 2FA during
                login, you can specify the mfa claim path.`,mapUser:"You can map a user to be a Rauthy admin depending on an upstream ID claim.",valueAdminClaim:"Admin Claim Value",valueMfaClaim:"MFA Claim Value"},delete:{areYouSure:"Are you sure you want to delete this provider?",forceDelete:"Force Delete",isInUse1:"This provider is in use by active users!",isInUse2:`You can force delete it, but users without a local password or passkey
                will not be able to log in anymore.`,linkedUsers:"Linked Users"}},roles:{adminNoMod:"The <code>rauthy_admin</code> role is immutable.",delete1:"Are you sure you want to delete this role?",name:"Role Name"},scopes:{defaultNoMod:"This is a default OIDC Scope. These are immutable.",delete1:"Are you sure you want to delete this scope?",deleteDefault:"OIDC Default Scopes können nicht gelöscht werden.",mapping1:"You can map custom scopes to attributes.",mapping2:`All additional attributes, that were configured, can have a custom value for each user.
            When they are mapped to a scope, they can be included in the Access and / or ID Tokens.`,name:"Scope Name"},search:{orderBy:"Order by ...",orderChangeToAsc:"Change sort to ascending",orderChangeToDesc:"Change sort to descending"},sessions:{invalidateAll:"Invalidate All Sessions"},tabs:{config:"Config",delete:"Delete"},users:{attributes:"Attributes",deleteUser:"Are you sure you want to delete this user?",descAttr:"Set custom user attributes. All key / value pairs will be handles as String / JSON Value.",forceLogout:`Are you sure you want to invalidate all existing sessions and delete all refresh tokens
            for this user?`,lastLogin:"Last Login",manualInitDesc:`The user can also be initialized here, In this case though, you need to communicate the 
            password directly.`,manualInit:"Manual Initialization",mfaDelete1:"You can delete Passkeys for this users.",mfaDelete2:`Caution! The deletion of a Passkey <b>cannot be reverted</b> without the user
            doing a fully new registration.`,noMfaKeys:"This user has no registered Passkeys.",pkOnly1:"This is a passkey-only account.",pkOnly2:"This means that this user uses the passwordless login and has no password set at all.",pkOnly3:`If this user has lost all Passkeys, the account can be fully reset and a new password reset E-Mail
            can be sent. To achieve this, navigate to the 'MFA' tab an delete all existing passkeys.`,pwdNoInit:"The user has not performed the initial password reset yet.",pwdSendEmailBtn:"Send Reset E-Mail",pwdSendEmailDesc:"You may send out a new reset E-Mail, if the user has not received one.",savePassword:"Save Password",selfServiceDesc:"You can either set a new password, or send out a reset E-Mail.",sendResetEmail:"Send Reset E-Mail"},validation:{css:"Valid CSS Value",origin:"Valid Origin",uri:"Valid URI"}},s={api_key:{delete1:"이 API 키를 삭제하시겠습니까?",expires:"만료일",generate1:"이 API 키에 대한 새 Secret을 생성할 수 있습니다.",generate2:`이 Secret은 생성 이후 단 한 번만 볼 수 있습니다. 새 Secret이 생성되면 이전 Secret은
            사용할 수 없으며, 이 작업은 되돌릴 수 없습니다!`,generate3:"API 키는 HTTP <code>Authorization</code> 헤더에 다음과 같은 형식으로 제공해야 합니다.",generate4:"아래의 <code>curl</code> 요청으로 테스트할 수 있습니다.",generate5:"<code>jq</code> 가 설치되어 있지 않거나 위의 코드가 실패한 경우는 아래 코드를 사용하세요.",keyName:"API 키 이름",limitedValidity:"만료일"},attrs:{delete1:"이 속성을 삭제하시겠습니까?",desc:"설명",name:"속성 이름"},clients:{backchannelLogout:"If this client supports {{ OIDC_BCL }}, you can provide the URI here.",branding:{descHsl:`HSL 값으로 입력해야 합니다. 기본 색상만 제공하면 알파 채널 및 기타 값은
                테마에 의해 동적으로 설정됩니다.`,descFullCss:`다음 값은 완전히 유효한 <code>CSS 색상</code> 값이어야 합니다. 복잡한 계산이나 위에
                정의된 <code>CSS 변수</code> 를 사용할 수도 있습니다.`,descVariables:`색상의 각 레이블들은 동시에 CSS 변수의 이름입니다. 즉, 입력 칸에서 이를 참조할 수
                있습니다. (예: <code>hsla(var(--action) / .7)</code>)`},confidential:"기밀",confidentialNoSecret:"이 클라이언트는 기밀이 아닌 클라이언트이므로 Secret이 없습니다.",config:"클라이언트 설정",delete1:"이 클라이언트를 삭제하시겠습니까?",descAuthCode:`보안을 강화하기 위해 인증 코드의 유효 기간을 조정할 수 있습니다. 인증 코드는
            한 번만 사용할 수 있으며 기본적으로 60초 동안 유효합니다. 클라이언트가 로그인 절차를
            충분히 빠르게 수행할 수 있다면 유효 기간이 짧을수록 좋습니다.`,descClientUri:"로그인 페이지에 표시할 클라이언트 URI 및 연락처에 대한 정보입니다.",descName:`클라이언트 이름은 클라이언트 구성에 영향을 주지 않고 변경할 수 있으며,
            로그인 페이지에서만 표시됩니다.`,descOrigin:`추가로 허용되는 외부 오리진을 설정합니다. 일반적으로 클라이언트가 브라우저에서 직접
            Rauthy에 요청해야 하는 경우(일반적으로 SPA)에만 필요합니다.`,descPKCE:`클라이언트가 이를 지원하는 경우, 추가 보안을 위해 항상 S256 PKCE를 활성화해야 합니다.
            기밀이 아닌 클라이언트(예: SPA)를 사용하는 경우에는 충분한 보안을 위해 최소한 PKCE 챌린지 중
            하나를 활성화해야 합니다.`,descPKCEEnforce:`PKCE가 활성화된 경우, 반드시 사용되어야 합니다. 유효한 챌린지가 포함되지
            않은 로그인 요청은 거부됩니다.`,descUri:`원하는 만큼 리디렉션 URI를 제공할 수 있습니다. 각각의 끝에 <code>*</code> 를
            와일드카드로 사용할 수 있습니다.`,errConfidentialPKCE:"클라이언트는 기밀 또는 PKCE 챌린지 중 하나 이상 활성화되어야 합니다.",forceMfa:"강제 MFA",name:"클라이언트 이름",scim:{baseUri:`The SCIM base URI is the one from which the sub routes like 
                <code>{base_uri}/Users/{id}</base_uri></code> can be derived correctly.`,desc:"If this client supports {{ SCIM_LINK }}, you can activate it here.",enable:"Enable SCIMv2",groupSync:"Synchronize Groups",groupSyncPrefix:"Groups Filter Prefix",groupSyncPrefixDesc:`You can filter the groups for the synchronization by an optional prefix.
                For instance, if the groups <code>app:admins</code> and <code>app:users</code> exist, the prefix
                 <code>app:</code> would only sync these groups, as well as only those users that are linked to at least
                 one of these groups.`,reqDesc:"A few things are required for compatibility:",reqLi1:"The client must handle <code>externalId</code> correctly.",reqLi2:`At least <code>/Users</code> endpoints with <code>filter=externalId eq "*"</code> and
                <code>filter=userName eq "*"</code> must be supported.`,reqLi3:`If groups should be synchronized, <code>/Groups</code> must also support 
                <code>filter=displayName eq "*"</code>.`},scopes:{allowed:"허용된 범위",default:"기본 범위",desc:`허용된 범위는 <code>authorization_code</code> 플로우를 사용할 때 로그인 리디렉션 중에
                클라이언트가 동적으로 요청할 수 있는 범위입니다. 예를 들어 <code>password</code> 를
                사용할 때, 일부 문제를 해결하기 위해 기본 범위가 항상 토큰에 추가됩니다.`},secret:{doCache:"Cache Client Secret",cacheDuration:"Cache Duration (hours)",generate:"새 Secret 생성",rotateDesc1:`To make graceful updates and secret rotations possible, you have the ability to keep the
                current secret in an in-memory cache for some time. You can enter a value between 1 and 24 hours.`,rotateDesc2:"Caution: You should not cache the current secret if you had a leak!"},tokenLifetime:{p1:"토큰 수명은 액세스 토큰과 ID 토큰에 적용되며, 초 단위입니다.",p2:`클라이언트가 EdDSA 또는 ed25519 알고리즘을 지원하면, 항상 선호되는 옵션이어야 합니다.
                RSA 알고리즘은 호환성을 위해서만 존재합니다.`,p3:"Refresh 토큰의 알고리즘은 Rauthy에서만 사용되므로, 변경할 수 없습니다."}},common:{account:"계정",addNew:"생성",back:"뒤로",contact:"연락처",copiedToClip:"클립보드로 복사되었습니다.",details:"자세히",edit:"편집",enabled:"활성화",filter:"필터",from:"부터",information:"정보",language:"언어",loading:"로딩중...",name:"이름",nameExistsAlready:"이미 존재하는 이름입니다.",note:"참고",noEntries:"비어 있음",reset:"초기화",search:"검색",searchOptions:"검색 옵션",until:"까지"},docs:{book:"Rauthy에 대한 문서:",encryption:"암호화",encKeys:{header:"암호화 키",keyActive:"활성화된 키",keysAvailable:"가능한 키",migrate:"마이그레이션",migrateToKey:"기존의 모든 암호화된 값을 다음 키로 마이그레이션",p1:`이 키는 내부에서 사용되는 데이터베이스와는 별개로, 세션, 쿠키 등 추가 암호화에 사용됩니다.
                이 키는 정적으로 구성되지만 이 페이지에서 수동으로 변경 및 마이그레이션할 수 있습니다.`,p2:`활성 키는 Rauthy 설정 파일 또는 환경 변수에 정적으로 설정됩니다. 여기에서 동적으로 생성할 수
                없습니다. 모든 새 JWK 암호화는 항상 현재 활성 키를 사용합니다.`,p3:`기존 Secret을 모두 마이그레이션하는 경우, 데이터 세트가 큰 경우에는 완료하는 데 수 초가 걸릴 수
                있습니다.`,pNotPossible:"마이그레이션하려면 최소 2개의 암호화 키를 사용할 수 있어야 합니다."},hashing:{calculate:"계산",currValuesHead:"현재 값",currValues1:"백엔드의 현재 값은 다음과 같습니다.",currValuesNote:`참고: 백엔드의 로그인 시간은 Rauthy가 시작된 후 최소 5회 이상 로그인에 성공한 후에만
                측정된 가이드라인을 제공합니다. 기본값은 항상 새로 다시 시작한 후 2000 ms이며, 로그인에 성공할
                때마다 재계산됩니다.`,currValuesThreadsAccess:"사용 가능한 스레드 개수 (p_cost)",loginTimeHead:"로그인 시간에 대한 견해",loginTime1:`일반적으로 사용자는 모든 것이 가능한 한 빨리 처리되기를 원합니다. 하지만 안전한 로그인을
                위해 500~1000 ms 정도는 문제가 되지 않습니다. 로그인 시간이 너무 짧으면 해시의 강도가 낮아질 수
                있으므로 너무 짧아서는 안 됩니다.`,loginTime2:`이 유틸리티는 최대한의 보안을 제공하기 위해 로그인 시간을 500ms 미만으로 설정할 수
                없습니다.`,mCost1:`<code>m_cost</code> 는 해싱에 사용되는 <b>메모리 (in kB)</b> 양입니다.
                물론 값이 높을수록 좋지만, 시스템의 메모리를 고려하여야 합니다.<br>
                예를 들어 4개의 비밀번호를 동시에 해시하는 경우, 해시하는 동안 <code>4 x m_cost</code> 가
                필요합니다. 이러한 리소스를 사용할 수 있어야 합니다.`,mCost2:`<code>m_cost</code> 를 조정하는 것은 매우 쉽습니다. Rauthy가 사용해야 하는 최대 메모리 양을
                정의하고, 이를 최대 허용 병렬 로그인 수(<code>MAX_HASH_THREADS</code>)로 나눈 다음 소량의 정적
                메모리를 빼면 됩니다. 얼마나 많은 정적 메모리를 고려해야 하는지는 사용되는 데이터베이스와 총
                사용자 수에 따라 다르지만 일반적으로 <code>32~96MB</code> 범위가 적당합니다.`,mCost3:"허용되는 <code>m_cost</code> 의 최소값은 <code>32768</code> 입니다.",pCost1:`<code>p_cost</code> 는 해싱을 위한 <b>병렬 처리 수</b>를 정의합니다. 이 값은 대부분 Rauthy의
                기본값인 8 이내로 사용됩니다.`,pCost2:`일반적인으로 <code>p_cost</code> 는 사용가능한 코어의 2배로 설정됩니다.
                예를 들어, 4코어 시스템을 사용중이라면, <code>p_cost</code> 가 <code>8</code> 로 설정됩니다.
                단, 이 값은 구성된 허용된 병렬 로그인 (<code>MAX_HASH_THREADS</code>) 을 고려하여 적절히 줄여야
                합니다.`,tCost1:`<code>t_cost</code> 는 해싱을 위한 <b>시간</b> 을 정의합니다. <code>m_cost</code> 와
                <code>p_cost</code> 는 기본적으로 환경에 의해 주어지기 때문에, 이 값은 실제로 튜닝이 필요한
                유일한 값입니다.`,tCost2:`튜닝은 간단합니다. <code>m_cost</code> 와 <code>p_cost</code> 를 적절히 설정한 다음
                <code>t_cost</code> 를 로그인 목표 시간에 도달할 때까지 증가시키면 됩니다.`,utilityHead:"파라메터 계산 유틸리티",utility1:`이 도구를 사용하여 시스템에 적합한 값을 대략적으로 구할 수 있습니다. 이 도구는 시스템의
                실제 성능을 테스트하므로 모든 다른 서비스를 사용하는 상태에서 Rauthy를 실행해야 한다는 점에
                유의하세요. 해당 시스템의 일반적인 사용 환경에서 이 유틸리티를 실행해야 오버 튜닝을 방지할 수
                있습니다.`,utility2:`<code>m_cost</code> 은 옵션이며, 비어 있으면 안전한 최소값인 <code>32768</code> 이 사용됩니다.
                <code>p_cost</code> 은 옵션이며, 비어 있으면 시스템의 <code>모든 스레드</code> 를 사용합니다.`,time:"시간",targetTime:"목표 시간",tune:"중요: 이러한 값은 최종 아키텍처에서 설정되어야 합니다!",pDetials:`Argon2ID에 대한 자세한 소개를 원하신다면 온라인에 많은 자료가 있습니다. 이 가이드에서는 값에
                대한 아주 간략한 개요만 제공합니다. 다음 세 가지를 구성해야 합니다.`,pTune:"시스템의 성능에 따라 다릅니다. 성능이 좋을수록 더 안전한 값을 설정할 수 있습니다.",pUtility:`이 유틸리티는 플랫폼에 가장 적합한 Argon2ID 설정을 찾을 수 있도록 도와줍니다. Argon2ID는 현재
                사용 가능한 가장 안전한 비밀번호 해싱 알고리즘입니다. 이 알고리즘을 최대한 활용하려면 각 시스템에
                맞게 조정해야 합니다.`},openapi:"외부 애플리케이션을 통합하기 위한 Rauthy의 API 사용 방법:",openapiNote:`백엔드 설정에 따라 Swagger UI가 외부에 노출되지 않을 수도 있습니다.
            하지만 기본적으로 내부에서는 Swagger UI를 통해 정보를 확인할 수 있습니다.`,source:"Rauthy의 소스코드"},error:{needsAdminRole:`<b>rauthy_admin</b> 역할이 부여되지 않았습니다.<br/>
            관리자 패널에 접근할 수 없습니다.`,noAdmin:`Rauthy 관리자 계정에는 <b>MFA가 활성화</b>되어 있어야 합니다.<br>
            <b>계정</b> 으로 이동 후 MFA를 활성화하세요.<br>
            활성화 후에는 로그아웃한 뒤 다시 로그인해야 합니다.`},events:{eventLevel:"이벤트 레벨",eventType:"이벤트 타입"},groups:{delete1:"이 그룹을 삭제하시겠습니까?",name:"그룹 이름"},jwks:{alg:"알고리즘",p1:"토큰 서명에 사용되는 Json Web Keys(JWKs)입니다.",p2:`JWKs는 기본적으로 매월 1일마다 회전됩니다. 새로 생성된 모든 토큰의 경우, 주어진 알고리즘에 대해
            사용 가능한 최신 키만 서명에 사용됩니다. 현재 유효한 토큰에 대해 유효성을 검사하기 위해 이전 키는
            잠시 보관되며, 이후 자동으로 정리됩니다.`,p3:`키를 수동으로 회전할 수도 있습니다. Rauthy 인스턴스가 실행 중인 하드웨어에 따라 수 초가 걸릴 수
            있습니다.`,type:"타입",rotateKeys:"키 회전"},nav:{apiKeys:"API 키",attributes:"속성",blacklist:"블랙리스트",clients:"클라이언트",config:"설정",docs:"문서",events:"이벤트",groups:"그룹",providers:"공급자",roles:"역할",scopes:"범위",sessions:"세션",users:"사용자"},options:{expires:"만료일",lastSeen:"마지막 사용시간",state:"상태"},passwordPolicy:{configDesc:"새 비밀번호에 대한 정책입니다.",resetSet0:"0으로 설정하면 비활성화됩니다.",validForDays:"기간 제한",validityNew:"이전 비밀번호 사용 제한 정책입니다."},providers:{config:{allowInsecureTls:"안전하지 않은 TLS 허용",clientName:"클라이언트 이름",custRootCa:"사용자 지정 Root CA PEM 사용",descAuthMethod:`<code>/token</code> 엔드포인트에서 사용할 인증 방법입니다.<br>
                대부분의 인증 공급자는 <code>basic</code> 으로 작업해야 하며, 일부 인증 공급자는
                <code>post</code> 만 사용해야 합니다. 드문 경우지만 두 가지를 모두 사용해야 하는 경우도
                있습니다. 인증 공급자의 가이드대로 설정하시면 됩니다.`,descClientId:"인증 공급자가 제공한 클라이언트 ID",descClientName:"로그인 페이지에 표시될 클라이언트 이름",descClientSecret:`인증 공급자가 제공한 클라이언트 Secret입니다. 최소한 클라이언트
                Secret 또는 PKCE가 필요합니다.`,descScope:"로그인 리디렉션에 사용할 범위입니다. 공백으로 구분하여 입력합니다.",errNoAuthMethod:`클라이언트 Secret이 입력되어 있지만, 클라이언트 인증 방법이 활성화되어
                있지 않습니다.`,errConfidential:"최소한 기밀 클라이언트이거나 PKCE를 사용해야 합니다.",jsonPath:{p1:"업스트림 로그인 성공 후, ID 토큰의 값을 자동으로 매핑할 수 있습니다.",p2:`<code>경로</code>는 정규식과 같은 구문으로 지정해야 합니다. 단일 JSON 값이나
                    JSON 객체 또는 배열의 값으로 처리할 수 있습니다.`,p3:"<code>$.</code> 는 JSON 객체의 시작을 표시합니다.",p4:"<code>*</code> 는 경로에서 와일드카드로 사용됩니다.",p5:`<code>$.roles</code> 는 <code>&#123;"roles": "value"&#125;</code> 을 목표로
                    할 수 있습니다.`,p6:`<code>$.roles.*</code> 는 <code>&#123;"roles": ["value", "notMyValue"]&#125;</code>
                    과 같이 객체 또는 배열 내부의 값을 목표로 할 수 있습니다.`},lookup:"조회",pathAdminClaim:"관리자 Claim 경로",pathMfaClaim:"MFA Claim 경로",rootPemCert:"Root CA의 PEM 인증서",mapMfa:`공급자에서 사용자가 로그인하는 동안 2FA 이상을 사용했음을 나타내는 Claim을 발행하는 경우,
                MFA Claim 경로를 지정할 수 있습니다.`,mapUser:"업스트림 ID Claim 에 따라 사용자를 Rauthy 관리자로 매핑할 수 있습니다.",valueAdminClaim:"관리자 Claim 값",valueMfaClaim:"MFA Claim 값"},delete:{areYouSure:"이 공급자를 삭제하시겠습니까?",forceDelete:"강제 삭제",isInUse1:"이 공급자는 활성 사용자가 사용 중입니다!",isInUse2:`강제로 삭제할 수는 있지만 로컬 비밀번호나 패스키가 없는 사용자는 더 이상 로그인할 수
                없습니다.`,linkedUsers:"연결된 사용자"}},roles:{adminNoMod:"<code>rauthy_admin</code> 역할은 변경할 수 없습니다.",delete1:"이 역할을 삭제하시겠습니까?",name:"역할 이름"},scopes:{defaultNoMod:"이것은 OIDC 기본 범위 중 하나입니다. 변경할 수 없습니다.",delete1:"이 범위를 삭제하시겠습니까?",deleteDefault:"OIDC 기본 범위는 삭제할 수 없습니다.",mapping1:"사용자 지정 범위를 속성에 매핑할 수 있습니다.",mapping2:`구성된 모든 추가 속성은 각 사용자에 대해 사용자 지정 값을 가질 수 있습니다.
            이러한 속성이 범위에 매핑되면 액세스 및 ID 토큰에 포함될 수 있습니다.`,name:"범위 이름"},search:{orderBy:"정렬 기준",orderChangeToAsc:"오름차순으로 정렬",orderChangeToDesc:"내림차순으로 정렬"},sessions:{invalidateAll:"모든 세션 삭제"},tabs:{config:"설정",delete:"삭제"},users:{attributes:"속성",deleteUser:"이 사용자를 삭제하시겠습니까?",descAttr:"사용자 지정 속성을 설정합니다. 모든 키/값 쌍은 문자열/JSON 값으로 처리됩니다.",forceLogout:"기존 세션을 모두 삭제하고, 이 사용자의 모든 Refresh 토큰을 삭제하시겠습니까?",lastLogin:"마지막 로그인",manualInitDesc:`The user can also be initialized here, In this case though, you need to communicate the 
            password directly.`,manualInit:"Manual Initialization",mfaDelete1:"이 사용자의 패스키를 삭제할 수 있습니다.",mfaDelete2:"이 작업은 되돌릴 수 없습니다!",noMfaKeys:"등록된 패스키 없음",pkOnly1:"이 사용자는 패스키 전용 계정입니다.",pkOnly2:"이 사용자는 비밀번호 없는 로그인을 사용하며, 설정된 비밀번호가 없습니다.",pkOnly3:`이 사용자가 모든 비밀번호를 분실한 경우, 계정을 완전히 재설정하고 새로운 비밀번호
            재설정 이메일을 보낼 수 있습니다. 이렇게 하려면 'MFA' 탭으로 이동하여 기존의 모든 패스키를
            삭제하세요.`,pwdNoInit:"사용자가 아직 초기 비밀번호 재설정을 수행하지 않았습니다.",pwdSendEmailBtn:"재설정 이메일 보내기",pwdSendEmailDesc:"새 비밀번호를 설정하거나, 재설정 이메일을 보낼 수 있습니다.",savePassword:"비밀번호 저장",selfServiceDesc:"새 비밀번호를 설정하거나, 재설정 이메일을 보낼 수 있습니다.",sendResetEmail:"재설정 이메일 보내기"},validation:{css:"비정상적인 CSS",origin:"비정상적인 오리진",uri:"비정상적인 URI"}},e;function o(){return e}function d(){switch(t()){case"de":e=n;break;case"ko":e=s;break;default:e=i;break}}export{d as i,o as u};
